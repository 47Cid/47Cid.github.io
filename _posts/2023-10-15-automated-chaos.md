---
layout: post
title:  "Automated Chaos: A Brief Overview of Fuzzing"
categories: [fuzzing,vulnerability-research]
tags: [fuzzing, vulnerability-research]
---

# What is fuzzing, really?
Instead of giving a formal academic definition of fuzzing, I'm going to begin with this meme to give you a vague idea of what fuzzing is.

![This is an alt text.](/images/random.png "Much random")
Fuzzing inputs are only random sometimes, but they're bs most of the time.
A more proper definition can be found [here][1]

#### But let's begin with a more targeted approach to explore the world of fuzzing.
#### Let's begin with...

# Fuzzing Methods

## Whitebox fuzzing:
* Whitebox fuzzing involves fuzzing a program with complete access to its source code.
* Feedback is measured by modifying the source code during compilation of the program. But we'll get into that later ðŸ˜¸

## Greybox Fuzzing
* In this method, the tester has limited knowledge of the application, like function prototypes or the decompiled code.
* This approach can be really useful for fuzzing closed-source libraries with API documentation that's readily accessible.
* For example: *Microsoft Windows API*

## Blackbox Fuzzing
* When you find yourself with just the binary and no source code, this method is your best bet.
* Sometimes you might have to use emulation tools like Qemu or Unicorn to run binary files belonging to a different architecture.
* Feedback in this case is measured via binary instrumentation.

## Pitch-Blackbox Fuzzing
* Okay, so I got a little creative here and just made this term up. But by 'pitch-black' I mean programs that cannot be emulated.
* For example: Programs designed to interact with specific hardware components.
* This is known as the re-hosting problem[ [5] ]. This is a really big problem and there's very limited work done in this field [ [2], [3], [4] ].

## But what is feedback?
We need to somehow measure the efficacy of a fuzzing test.
We need to get some kind of 'feedback' from the process while it's being fuzzed.

The fuzzer could then leverage the feedback obtained from the target process and adapt its input generation.

Feedback is usually measured using various metrics such as:
1) Code Coverage: This is the most important form of feedback. It measures the extent to which the source code of a program has been executed during the testing process
2) Edge Coverage: Even [100%](https://roelofjanelsinga.com/articles/100-test-coverage-why-or-why-not/) code coverage does not guarantee effective testing. As such, measurement of the transitions between basic blocks in the control flow graph of the program can also provide useful insight during fuzzing.
3) Memory Usage: It can also be useful to keep track of how the target application allocates and deallocates memory during the execution of test cases.
4) Input Validation: It is might be helpful for the fuzzer to know whether the input being supplied to the target process is valid.

> **Note:** The terms "feedback-driven" and "coverage-guided" are frequently used interchangeably, but they are not necessarily the same. Feedback-driven fuzzing is a broader term that encompasses coverage-guided fuzzing.

### Coverage Tools
afl-plot, afl-cov
### VSCode Plugin For Code Coverage
* https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters
#### Ghidra Plugin For Code Coverage
* https://github.com/nccgroup/Cartographer
* https://github.com/0ffffffffh/dragondance

## Instrumentation
Instrumentation is the process of injecting additional code into a program to collect data about its runtime or to modify the program's behavior.

## Source Code Instrumentation:
Fuzzers can instrument the source code to collect coverage information by directly modifying it to add additional code during compilation.
AFL enables source code instrumentation by integrating with other compilers. 
```bash
afl-gcc fuzz.c -o fuzz
```
AFL can also use the LLVM compiler to insert instrumentation code using LLVM passes
```bash
afl-clang-lto fuzz.c -o fuzz
```

## Binary Instrumentation:  
Binary instrumentation, as the name suggests, involves modifying the compiled binary code of a program to insert additional instructions.

For instance, you can use dynamic instrumentation toolkits like [Frida](https://frida.re/) to inject JavaScript or native code into running processes or intercept and modify function calls.

> **Note:** It might be possible to whip up a pretty interesting coverage guided fuzzer using Frida, but I'm not sure how well it would perform. To my knowledge, I don't think anyone has done this.


## Mutations
Mutation-based fuzzing is a technique where new test inputs are generated by tweaking existing inputs.

In the case of feedback-driven fuzzing, the feedback information is used to guide further mutations.
Inputs that lead to new or uncovered code paths are considered interesting and may be prioritized for further mutation

Mutation-Based:
- Bit flips: Randomly flipping individual bits in the input.
- Byte flips: Randomly flipping entire bytes in the input.
- Insertions: Inserting random data into the input.
- Deletions: Removing portions of the input.

AFL is a wildcard because of custom mutators (Grammar-Mutator)
https://aflplus.plus/features/

## Input Seed Generation:
The initial set of seed inputs in the corpus serves as a starting point for the fuzzer. These seeds are typically valid inputs that help the fuzzer understand the structure and expected format of input data.




Generate More Crashes (Santizers)
ASAN works by mapping the program's memory to a shadow map. This takes up more space and hence the -m none flag is needed

#### Some pitfalls:
Too much IO is bad!
* https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/
* https://www.cipherdyne.org/blog/2014/12/ram-disks-and-saving-your-ssd-from-afl-fuzzing.html

TLDR: tmpfs based file system is best. It's also better than ramfs because it does not grow dynamically

I also added --memory tag

```bash
docker pull aflplusplus/aflplusplus

docker run -ti -v ~/src-dir:/src --memory=1024m \
--mount type=tmpfs,destination=/ramdisk -e \
AFL_TMPDIR=/ramdisk aflplusplus/aflplusplus
```



[1]: https://owasp.org/www-community/Fuzzing
[2]: https://dl.acm.org/doi/10.1145/3423167
[3]: https://hernan.de/research/papers/firmwire-ndss22-hernandez.pdf
[4]: https://dl.acm.org/doi/10.1145/3427228.3427294
[5]: https://www.s3.eurecom.fr/docs/asiaccs22_mantovani.pdf
